<!doctype html>
<html lang="bg">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Crypto Screener — Real TA (30m/1h/4h/24h)</title>
<style>
  :root{--bg:#0f1115;--card:#161a22;--text:#e6e6e6;--muted:#a3a3a3;--pos:#22c55e;--neg:#ef4444;--accent:#60a5fa}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial;background:var(--bg);color:var(--text)}
  
  /* фиксиран header */
  header{
    padding:16px;
    display:flex;gap:12px;flex-wrap:wrap;
    align-items:center;justify-content:space-between;
    background:#0c0f14;
    position:fixed;
    top:0;left:0;right:0;
    z-index:20;
    border-bottom:1px solid #202635
  }
  
  h1{font-size:18px;margin:0;font-weight:600}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  button, select, input{background:var(--card);color:var(--text);border:1px solid #2a3142;border-radius:10px;padding:8px 10px;font-size:13px}
  button:hover{cursor:pointer;border-color:#3a445a}
  .badge{padding:4px 8px;border-radius:999px;font-size:12px;border:1px solid #2a3142;color:var(--muted)}
  
  main{padding:96px 16px 16px}
  
  /* FIX: flex, за да не изчезва topBull */
  .summary{margin-bottom:16px;display:flex;flex-wrap:wrap;gap:16px}
  .summary .card{flex:1 1 0;min-width:280px}
  @media (max-width:980px){
    .summary{flex-direction:column}
  }

  .card{background:var(--card);border:1px solid #202635;border-radius:12px;padding:12px}
  .card h3{margin:0 0 8px;font-size:13px;color:var(--muted)}
  ul{list-style:none;margin:0;padding:0}
  li{padding:4px 0;font-size:13px}
  .pos{color:var(--pos)}
  .neg{color:var(--neg)}
  .table-wrap{background:var(--card);border:1px solid #202635;border-radius:12px;overflow:hidden}
  .table-container{overflow:auto}
  table{width:100%;border-collapse:collapse;font-size:13px;min-width:1000px}
  
  thead th{
    background:#121722;
    position:sticky;
    top:0;
    z-index:5;
    padding:10px;
    text-align:center
  }
  
  th,td{padding:10px;border-bottom:1px solid #202635;text-align:center;vertical-align:middle}
  tbody tr:hover{background:#121621}
  .green{color:var(--pos);font-weight:700}
  .red{color:var(--neg);font-weight:700}
  .mono{font-variant-numeric:tabular-nums}
  .comment{text-align:left;color:var(--muted);max-width:320px}
  .loading{padding:24px;text-align:center;color:var(--muted)}
  .small{font-size:12px;color:var(--muted)}
  #progressWrap{background:rgba(255,255,255,0.03);border-radius:8px;padding:6px;margin-left:8px;min-width:220px}
  #progress{height:8px;background:linear-gradient(90deg,var(--accent),#00b39f);border-radius:6px;width:0%;transition:width .2s}
  
  @media (max-width:980px){
    .desktop-only{display:none}
    table{font-size:12px;min-width:900px}
    main{padding-top:88px}
  }
</style>

</head>
<body>
<header>
  <div style="display:flex;gap:12px;align-items:center">
    <h1>Технически анализ — Top 100/200 (Binance klines + Real TA)</h1>
    <span class="small" style="margin-left:8px;color:var(--muted)">Timeframe:</span>
    <select id="timeframe" title="Избери timeframe">
      <option value="30m">30m</option>
      <option value="1h" selected>1h</option>
      <option value="4h">4h</option>
      <option value="1d">24h</option>
    </select>
  </div>

  <div class="controls">
    <span class="badge" id="lastUpdated">Обновяване…</span>
    <select id="sortBy">
      <option value="change">Сортирай по очаквана промяна ↓</option>
      <option value="price">Сортирай по цена ↓</option>
      <option value="name">Сортирай по име A→Z</option>
    </select>
    <input id="search" placeholder="Търси (име или символ)..." />
    <button id="download">Свали CSV</button>
    <button id="reload">Презареди</button>
    <button id="load200">Зареди топ 200</button>
    <div id="progressWrap"><div id="progress"></div></div>
  </div>
</header>

<main>
  <div class="summary">
    <div class="card">
      <h3>Топ 5 възходящи</h3>
      <ul id="topBull"></ul>
    </div>
    <div class="card">
      <h3>Топ 5 низходящи</h3>
      <ul id="topBear"></ul>
    </div>
  </div>

  <div class="table-wrap">
    <div id="status" class="loading">Готов за зареждане. Избери timeframe и натисни "Презареди" или "Зареди топ 200".</div>
    <div class="table-container">
      <table id="table" style="display:none">
        <thead>
          <tr>
            <th>Валута</th>
            <th>Цена (USDT)</th>
            <th>Δ% (посл. candle)</th>
            <th>RSI(14)</th>
            <th>MACD</th>
            <th>BB pos</th>
            <th>Очаквана промяна %</th>
            <th>Очаквана цена</th>
            <th>Buy</th>
            <th>Sell</th>
            <th>Коментар</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
  <div class="small" style="margin-top:8px;color:var(--muted)">API: CoinGecko (top list) + Binance (klines). Хостинг: GitHub Pages (static).</div>
</main>

<script>
/*
  Single-file screener using CoinGecko + Binance klines
  - Timeframes: 30m, 1h, 4h, 1d
  - Indicators: RSI(14), EMA(12/26), MACD(12,26,9), Bollinger Bands(20,2)
  - Concurrency-limited fetching & batching to avoid rate limits
  - Output: table with signals, CSV export
*/

const el = {
  status: document.getElementById('status'),
  table: document.getElementById('table'),
  tbody: document.querySelector('#table tbody'),
  sortBy: document.getElementById('sortBy'),
  search: document.getElementById('search'),
  download: document.getElementById('download'),
  reload: document.getElementById('reload'),
  load200: document.getElementById('load200'),
  last: document.getElementById('lastUpdated'),
  topBull: document.getElementById('topBull'),
  topBear: document.getElementById('topBear'),
  timeframe: document.getElementById('timeframe'),
  progress: document.getElementById('progress')
};

let ROWS = [];
let lastFetchedAt = null;

// Helpers: numeric
const toFixed = (n, d=4) => (Number.isFinite(n) ? Number(n).toFixed(d) : '—');

// Fetch helpers with retry
async function fetchJSON(url, tries=3){
  try{
    const r = await fetch(url);
    if(!r.ok) throw new Error('HTTP '+r.status);
    return await r.json();
  } catch(e){
    if(tries>1){ await new Promise(r=>setTimeout(r,400)); return fetchJSON(url,tries-1); }
    throw e;
  }
}

// TA helpers
function sma(arr, period){
  if(arr.length < period) return null;
  const res = [];
  let sum = 0;
  for(let i=0;i<arr.length;i++){
    sum += arr[i];
    if(i>=period) sum -= arr[i-period];
    if(i >= period-1) res.push(sum/period);
  }
  return res;
}
function stddev(arr, period){
  if(arr.length < period) return null;
  const res = [];
  for(let i=0;i<=arr.length-period;i++){
    const slice = arr.slice(i,i+period);
    const mean = slice.reduce((a,b)=>a+b,0)/period;
    const variance = slice.reduce((a,b)=>a + (b-mean)**2,0)/period;
    res.push(Math.sqrt(variance));
  }
  return res;
}
function ema(arr, period){
  if(arr.length < period) return null;
  const k = 2/(period+1);
  const res = [];
  let prev = arr.slice(0,period).reduce((a,b)=>a+b,0)/period;
  res.push(prev);
  for(let i=period;i<arr.length;i++){
    const cur = arr[i]*k + prev*(1-k);
    res.push(cur);
    prev = cur;
  }
  return res;
}
function rsi(closes, period=14){
  if(closes.length < period+1) return null;
  let gains=0, losses=0;
  for(let i=1;i<=period;i++){
    const d = closes[i]-closes[i-1];
    if(d>0) gains += d; else losses += Math.abs(d);
  }
  let avgGain = gains/period, avgLoss = losses/period;
  for(let i=period+1;i<closes.length;i++){
    const d = closes[i]-closes[i-1];
    avgGain = ((avgGain*(period-1)) + (d>0?d:0))/period;
    avgLoss = ((avgLoss*(period-1)) + (d<0?Math.abs(d):0))/period;
  }
  if(avgLoss === 0) return 100;
  const rs = avgGain/avgLoss;
  return 100 - (100/(1+rs));
}
function macdVals(closes, fast=12, slow=26, signal=9){
  if(closes.length < slow+signal) return null;
  const emaFast = ema(closes, fast);
  const emaSlow = ema(closes, slow);
  if(!emaFast || !emaSlow) return null;
  // align: emaFast length = closes.length - fast +1, emaSlow = closes.length - slow +1
  // compute MACD series where both exist: start index = (slow - fast)
  const startOffset = slow - fast;
  const macd = [];
  for(let i=0;i<emaSlow.length;i++){
    const f = emaFast[i + startOffset];
    const s = emaSlow[i];
    macd.push(f - s);
  }
  const signalLine = ema(macd, signal);
  if(!signalLine) return null;
  // macd and signalLine aligned: signalLine corresponds to macd indices starting at signal-1
  // We'll return last macd and last signal
  const macdLast = macd[macd.length - 1];
  const signalLast = signalLine[signalLine.length - 1];
  return {macdSeries:macd, signalSeries:signalLine, macdLast, signalLast};
}

// Map CoinGecko -> Binance symbol (try USDT, then BUSD)
async function getBinanceSymbolsSet(){
  const info = await fetchJSON('https://api.binance.com/api/v3/exchangeInfo');
  const symbols = new Set(info.symbols.map(s => s.symbol));
  return symbols;
}

// Compute signals based on indicators
function deriveSignalsFromTA(lastClose, closes, indicators){
  // indicators: { rsiVal, macdLast, signalLast, bb: {upper, middle, lower} }
  const flags = {};
  // RSI flag
  flags.rsiBull = indicators.rsiVal !== null && indicators.rsiVal < 35; // oversold
  flags.rsiBear = indicators.rsiVal !== null && indicators.rsiVal > 70; // overbought
  // MACD flag
  flags.macdBull = indicators.macdLast !== null && indicators.signalLast !== null && indicators.macdLast > indicators.signalLast;
  flags.macdBear = indicators.macdLast !== null && indicators.signalLast !== null && indicators.macdLast < indicators.signalLast;
  // BB position
  flags.bbUpper = indicators.bb && lastClose > indicators.bb.upper;
  flags.bbMiddle = indicators.bb && Math.abs(lastClose - indicators.bb.middle) < (indicators.bb.upper - indicators.bb.middle)*0.1;
  flags.bbLower = indicators.bb && lastClose < indicators.bb.lower;
  // momentum short-term: compare last candle relative change
  const last = closes[closes.length-1], prev = closes[closes.length-2] || closes[closes.length-1];
  const pct = prev ? (last - prev)/prev*100 : 0;
  flags.momentumUp = pct > 1.0;
  flags.momentumDown = pct < -1.5;
  return {flags, pct};
}

// Expected change scoring: combine flags into % score
function expectedChangeFromFlags(flags, pctShort){
  let pts = 0;
  if(flags.rsiBull) pts += 2;
  if(flags.rsiBear) pts -= 2;
  if(flags.macdBull) pts += 1.5;
  if(flags.macdBear) pts -= 1.5;
  if(flags.bbUpper) pts += 1.5;
  if(flags.bbLower) pts -= 1.5;
  if(flags.momentumUp) pts += 1;
  if(flags.momentumDown) pts -= 1.2;
  pts += clamp(pctShort * 0.2, -3, 3); // small contribution from immediate candle
  return clamp(pts, -20, 20);
}

function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

// Build comment text
function commentFromFlags(flags){
  const bits = [];
  if(flags.macdBull) bits.push('MACD bullish');
  if(flags.rsiBull) bits.push('RSI oversold -> rebound');
  if(flags.bbUpper) bits.push('Above BB upper');
  if(flags.momentumUp) bits.push('Short momentum');
  if(flags.macdBear) bits.push('MACD bearish');
  if(flags.rsiBear) bits.push('RSI overbought');
  if(flags.bbLower) bits.push('Below BB lower');
  return bits.length ? bits.slice(0,3).join('; ') : 'Neutral';
}

// Main load flow
async function load(limit=100){
  el.progress.style.width = '2%';
  el.status.style.display = 'block';
  el.table.style.display = 'none';
  el.status.textContent = 'Зареждане: взимане на списък с монети от CoinGecko...';
  try{
    const timeframe = el.timeframe.value; // '30m','1h','4h','1d'
    const per_page = limit;
    const url = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=${per_page}&page=1&sparkline=false`;
    const coins = await fetchJSON(url);
    el.status.textContent = `Намерени ${coins.length} монети. Зареждам Binance symbols...`;
    el.progress.style.width = '8%';

    const symbolsSet = await getBinanceSymbolsSet();
    el.progress.style.width = '12%';
    // Map coins -> binance symbols attempts
    const mapped = coins.map(c => {
      const sym = (c.symbol || '').toUpperCase();
      const try1 = sym + 'USDT';
      const try2 = sym + 'BUSD';
      if(symbolsSet.has(try1)) return {...c, binance: try1};
      if(symbolsSet.has(try2)) return {...c, binance: try2};
      // handle special cases: some tokens have suffixes (e.g., 'WBTC' vs 'BTC')
      return {...c, binance: null};
    });

    // Filter to those with binance symbol; keep originals without mapping for info
    const toProcess = mapped.filter(m => m.binance);
    if(toProcess.length === 0){
      el.status.textContent = 'Няма съвпадения с Binance trading pairs. Мапингът не намери USDT/BUSD пазари.';
      return;
    }
    el.status.textContent = `Ще обработя ${toProcess.length} монети (mapped to Binance). Изтеглям klines за timeframe ${timeframe}...`;
    el.progress.style.width = '16%';

    // concurrency control
    const concurrency = 6;
    const results = [];
    let idx = 0;
    const total = toProcess.length;
    // helper to fetch klines for a symbol
    const intervalMap = {'30m':'30m','1h':'1h','4h':'4h','1d':'1d'};
    const limitK = 300; // candles; usually enough for indicators
    async function worker(){
      while(true){
        const i = idx++;
        if(i >= total) break;
        const item = toProcess[i];
        try {
          const klinesUrl = `https://api.binance.com/api/v3/klines?symbol=${item.binance}&interval=${intervalMap[timeframe]}&limit=${limitK}`;
          const kl = await fetchJSON(klinesUrl).catch(e => { throw new Error('klines error '+e.message); });
          if(!Array.isArray(kl) || kl.length===0) throw new Error('no klines');
          const closes = kl.map(k => Number(k[4]));
          const highs = kl.map(k => Number(k[2]));
          const lows = kl.map(k => Number(k[3]));
          const lastClose = closes[closes.length-1];
          const prevClose = closes[closes.length-2] || lastClose;
          const pctCandle = prevClose ? (lastClose - prevClose)/prevClose*100 : 0;

          // indicators
          const rsiVal = rsi(closes,14);
          const macdRes = macdVals(closes,12,26,9);
          const bbSma = sma(closes,20);
          const bbStd = stddev(closes,20);
          let bb = null;
          if(bbSma && bbStd){
            const m = bbSma[bbSma.length-1];
            const s = bbStd[bbStd.length-1];
            bb = {middle: m, upper: m + 2*s, lower: m - 2*s};
          }
          const macdLast = macdRes ? macdRes.macdLast : null;
          const signalLast = macdRes ? macdRes.signalLast : null;

          // derive signals
          const {flags, pct} = deriveSignalsFromTA(lastClose, closes, {rsiVal, macdLast, signalLast, bb});
          const expected = expectedChangeFromFlags(flags, pct);
          // buy/sell/support/resistance using recent high/low and expected change
          const support = (lows.slice(-20).reduce((a,b)=>Math.min(a,b), Infinity) === Infinity) ? (lastClose*0.98) : lows.slice(-20).reduce((a,b)=>Math.min(a,b), lastClose);
          const resistance = (highs.slice(-20).reduce((a,b)=>Math.max(a,b), -Infinity) === -Infinity) ? (lastClose*1.02) : highs.slice(-20).reduce((a,b)=>Math.max(a,b), lastClose);
          const buy = Math.min(lastClose*0.995, support*1.01);
          const sell = Math.max(lastClose*1.01, resistance*0.99);
          const expPrice = lastClose*(1+expected/100);

          results.push({
            name: item.name + ' (' + item.symbol.toUpperCase() + ')',
            symbol: item.symbol.toUpperCase(),
            binance: item.binance,
            price: lastClose,
            pctCandle,
            rsi: rsiVal,
            macd: macdLast,
            signal: signalLast,
            bb,
            flags,
            expectedChange: expected,
            expPrice,
            buy, sell, support, resistance,
            comment: commentFromFlags(flags)
          });
        } catch(err){
          // push an object with error so render can skip gracefully
          results.push({ name: item.name + ' (' + item.symbol.toUpperCase() + ')', symbol: item.symbol.toUpperCase(), error: String(err) });
        }
        const percent = Math.round((results.length/total)*80) + 16; // map progress between 16%..96%
        el.progress.style.width = percent + '%';
        el.status.textContent = `Обработени ${results.length}/${total}...`;
        // polite pause to avoid bursts
        await new Promise(r=>setTimeout(r, 150));
      }
    }

    // start workers
    const workers = [];
    for(let i=0;i<concurrency;i++) workers.push(worker());
    await Promise.all(workers);
    // store results
    ROWS = results.filter(r => !r.error);
    lastFetchedAt = new Date();
    el.last.textContent = 'Обновено: ' + lastFetchedAt.toLocaleString();
    el.progress.style.width = '100%';
    el.status.textContent = 'Готово. Рендиране...';
    render();
  } catch(e){
    console.error(e);
    el.status.textContent = 'Грешка: ' + (e.message || e);
    el.progress.style.width = '0%';
  }
}

// Render function: search, sort, table populate, top lists
function render(){
  const q = (el.search.value || '').toLowerCase();
  let f = ROWS.filter(r => !q || (r.name && r.name.toLowerCase().includes(q)) || (r.symbol && r.symbol.toLowerCase().includes(q)));
  const key = el.sortBy.value;
  f.sort((a,b) => {
    if(key === 'name') return (a.name||'').toLowerCase().localeCompare((b.name||'').toLowerCase());
    if(key === 'price') return (b.price||0) - (a.price||0);
    return (b.expectedChange||0) - (a.expectedChange||0);
  });

  // render rows
  el.tbody.innerHTML = '';
  f.forEach(r => {
    const changeClass = (r.expectedChange >= 0) ? 'green' : 'red';
    const rsiTxt = r.rsi !== null ? toFixed(r.rsi,2) : '—';
    const macdTxt = r.macd !== null ? toFixed(r.macd,4) : '—';
    const bbPos = r.bb ? (r.price > r.bb.upper ? 'Above' : (r.price < r.bb.lower ? 'Below' : 'Middle')) : '—';
    el.tbody.insertAdjacentHTML('beforeend', `
      <tr>
        <td style="text-align:left"><strong>${r.symbol}</strong><div class="small" style="color:var(--muted)">${r.name}</div></td>
        <td>${toFixed(r.price,4)}</td>
        <td class="mono ${r.pctCandle>=0?'green':'red'}">${toFixed(r.pctCandle,2)}%</td>
        <td>${rsiTxt}</td>
        <td>${macdTxt}</td>
        <td>${bbPos}</td>
        <td class="mono ${changeClass}">${toFixed(r.expectedChange,2)}%</td>
        <td>${toFixed(r.expPrice,4)}</td>
        <td>${toFixed(r.buy,4)}</td>
        <td>${toFixed(r.sell,4)}</td>
        <td class="comment">${escapeHtml(r.comment)}</td>
      </tr>
    `);
  });

  el.status.style.display = 'none';
  el.table.style.display = (f.length>0) ? 'table' : 'none';

  // top lists
  const sortedByExp = [...ROWS].sort((a,b)=> (b.expectedChange||0) - (a.expectedChange||0));
  const topBull = sortedByExp.slice(0,5);
  const topBear = sortedByExp.slice(-5).reverse();
  el.topBull.innerHTML = topBull.map(r => `<li class="pos">${r.name}: ${toFixed(r.expectedChange,2)}%</li>`).join('');
  el.topBear.innerHTML = topBear.map(r => `<li class="neg">${r.name}: ${toFixed(r.expectedChange,2)}%</li>`).join('');
}

// CSV export
function toCSV(rows){
  const headers = ['Name','Symbol','Binance','Price','PctCandle','RSI','MACD','BBpos','ExpectedChange%','ExpPrice','Buy','Sell','Support','Resistance','Comment'];
  const lines = [headers.join(',')];
  rows.forEach(r => {
    lines.push([
      csvSafe(r.name),
      r.symbol,
      r.binance,
      toFixed(r.price,6),
      toFixed(r.pctCandle,4),
      r.rsi !== null ? toFixed(r.rsi,4) : '',
      r.macd !== null ? toFixed(r.macd,6) : '',
      r.bb ? (r.price > r.bb.upper ? 'above' : (r.price < r.bb.lower ? 'below' : 'middle')) : '',
      toFixed(r.expectedChange,4),
      toFixed(r.expPrice,6),
      toFixed(r.buy,6),
      toFixed(r.sell,6),
      toFixed(r.support,6),
      toFixed(r.resistance,6),
      `"${(r.comment||'').replaceAll('"','""')}"`
    ].join(','));
  });
  return lines.join('\n');
}
function csvSafe(s){ return `"${String(s||'').replaceAll('"','""')}"`; }
function escapeHtml(s){ if(!s) return ''; return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }

// UI wiring
el.reload.addEventListener('click', ()=> load(100));
el.load200.addEventListener('click', ()=> load(200));
el.download.addEventListener('click', ()=>{
  if(!ROWS || ROWS.length===0){ alert('Няма данни — направете зареждане първо.'); return; }
  const csv = toCSV(ROWS);
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([csv], {type:'text/csv'}));
  a.download = `screener_ta_${el.timeframe.value}_${(new Date()).toISOString().slice(0,19)}.csv`;
  document.body.appendChild(a); a.click(); a.remove();
});
el.search.addEventListener('input', render);
el.sortBy.addEventListener('change', render);
el.timeframe.addEventListener('change', ()=> { /* auto-reload on timeframe change */ if(confirm('Смяна на timeframe, искате ли да презаредите данните с новия timeframe?')) load(ROWS.length>150?200:100); });

// initial small helper: load default 100 on first open
// but do not auto-run if user wants to click — we'll auto-run to be friendly
load(100);

</script>
</body>
</html>

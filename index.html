<!doctype html>
<html lang="bg">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Crypto Screener — TA (30m / 1h / 4h)</title>
<style>
  :root{--bg:#0b0f14;--card:#0f1720;--muted:#9aa4b2;--accent:#00b39f;--danger:#ff6b6b;--glass:rgba(255,255,255,0.03)}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial;color:#e6eef6;background:linear-gradient(180deg,#071021 0%, #071727 100%);padding:20px}
  header{display:flex;align-items:center;gap:16px;margin-bottom:18px}
  h1{font-size:18px;margin:0;color:#dff7f2}
  .controls{margin-left:auto;display:flex;gap:8px;align-items:center}
  .tf-btn{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:6px 10px;border-radius:6px;cursor:pointer}
  .tf-btn.active{border-color:var(--accent);color:#cff7ef;box-shadow:0 4px 16px rgba(0,179,159,0.08);background:linear-gradient(90deg, rgba(0,179,159,0.06), transparent)}
  .main{display:flex;gap:20px}
  .panel{background:var(--card);padding:14px;border-radius:12px;box-shadow:0 6px 24px rgba(2,6,12,0.6);flex:1}
  table{width:100%;border-collapse:collapse;color:#e8f3ff;font-size:13px}
  th,td{padding:8px 10px;text-align:left;border-bottom:1px dashed rgba(255,255,255,0.03)}
  th{color:var(--muted);font-size:12px}
  tr:hover td{background:var(--glass)}
  .pill{padding:4px 8px;border-radius:999px;font-weight:600;font-size:12px}
  .buy{background:linear-gradient(90deg,#004a40,#007a63);color:#d6fff4}
  .sell{background:linear-gradient(90deg,#4a0a0a,#7a0022);color:#ffd7d7}
  .hold{background:linear-gradient(90deg,#3b3f49,#1f2430);color:#ddd}
  .muted{color:var(--muted);font-size:12px}
  .top-actions{display:flex;gap:8px;align-items:center;margin-bottom:10px}
  .btn{background:var(--accent);border:none;color:#00221a;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:700}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  #progress{height:6px;background:linear-gradient(90deg,#00b39f,#008f7a);border-radius:4px;width:0%;transition:width .25s}
  .small{font-size:12px;color:var(--muted)}
  footer{margin-top:14px;color:var(--muted);font-size:12px}
  @media (max-width:900px){.main{flex-direction:column}}
</style>
</head>
<body>
<header>
  <img src="https://raw.githubusercontent.com/tehlerian/trade4/main/icon.png" alt="" style="width:40px;height:40px;border-radius:8px;object-fit:cover;filter:drop-shadow(0 6px 16px rgba(0,0,0,.6))">
  <div>
    <h1>Технически анализ — Top (TA + Коментар)</h1>
    <div class="small">Анализ на базата на последни <span id="current-tf-label">1 час</span>. Сменете timeframe със стрелките вдясно.</div>
  </div>
  <div class="controls">
    <button class="tf-btn" data-tf="4h">4 часа</button>
    <button class="tf-btn active" data-tf="1h">1 час</button>
    <button class="tf-btn" data-tf="30m">30 мин</button>
  </div>
</header>

<div class="main">
  <div class="panel" style="flex:1.2">
    <div class="top-actions">
      <button id="load-btn" class="btn">Зареди анализ</button>
      <button id="reload-btn" class="btn ghost">Презареди</button>
      <button id="csv-btn" class="btn ghost">Свали CSV</button>
      <div style="flex:1"></div>
      <div class="small">Сортирай: <select id="sort-select"><option value="exp">Очаквана промяна ↓</option><option value="price">Цена ↓</option><option value="name">Име A→Z</option></select></div>
    </div>

    <div style="width:100%;background:rgba(255,255,255,0.03);padding:6px;border-radius:8px;margin-bottom:10px">
      <div id="status" class="small">Готов за анализ.</div>
      <div style="margin-top:8px;background:rgba(255,255,255,0.02);padding:3px;border-radius:6px">
        <div id="progress" aria-hidden="true"></div>
      </div>
    </div>

    <div style="overflow:auto;max-height:64vh">
      <table id="result-table">
        <thead>
          <tr>
            <th>Валута</th>
            <th>Текуща цена (USDT)</th>
            <th>Δ% (посл. candle)</th>
            <th>Сигнали</th>
            <th>SMA slope</th>
            <th>RSI(14)</th>
            <th class="muted">Коментар</th>
          </tr>
        </thead>
        <tbody id="tbody">
          <tr><td colspan="7" class="muted">Натиснете "Зареди анализ" за да започнете — страницата ще провери кои монети имат символи на Binance и ще свали данни.</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <div class="panel" style="flex:0.6">
    <h3 style="margin-top:0">Топ резултати</h3>
    <div id="top5-up" class="small muted">Топ 5 възходящи ще се покажат тук.</div>
    <hr style="border:none;border-top:1px dashed rgba(255,255,255,0.04);margin:10px 0">
    <h3 style="margin:0">Настройки</h3>
    <div style="margin-top:10px" class="small">
      <strong>Източници:</strong><br>CoinGecko (top coins) + Binance (klines).<br><br>
      <strong>Интервали:</strong><br>30m / 1h / 4h — смяна с бутоните горе.<br><br>
      <strong>Бележки:</strong><br>Кодът работи директно в браузъра. Ако искаш да гледаш друг exchange — казвай.
    </div>
    <hr style="border:none;border-top:1px dashed rgba(255,255,255,0.04);margin:10px 0">
    <div class="small">
      <strong>Лесни подобрения:</strong>
      <ul>
        <li>Добавяне на MACD/ATR/EMA и candle pattern detection</li>
        <li>Сървърна кеширана версия за много бързо зареждане</li>
      </ul>
    </div>
  </div>
</div>

<footer>
  <div>Създадено като копие/надстройка върху интерфейс — възможност за timeframe: <strong id="tf-footer">1h</strong>. API: CoinGecko + Binance. Ако искаш, експортирам и версия със сигнали за твоя watchlist.</div>
</footer>

<script>
/*
  Single-file frontend screener:
  - fetch top coins (CoinGecko)
  - map to Binance symbols (SYMBOLUSDT)
  - fetch klines for selected timeframe (30m,1h,4h)
  - compute indicators: %change, SMA(20) slope, RSI(14)
  - produce basic buy/hold/sell signal
  - allow switching timeframe by clicking buttons (no reload required)
*/

const TF_MAP = {
  '30m': {label: '30 мин', binance:'30m'},
  '1h': {label: '1 час', binance:'1h'},
  '4h': {label: '4 часа', binance:'4h'}
};

let currentTF = '1h';
document.getElementById('current-tf-label').textContent = TF_MAP[currentTF].label;
document.getElementById('tf-footer').textContent = currentTF;

document.querySelectorAll('.tf-btn').forEach(b=>{
  b.addEventListener('click', ()=> {
    document.querySelectorAll('.tf-btn').forEach(x=>x.classList.remove('active'));
    b.classList.add('active');
    currentTF = b.getAttribute('data-tf');
    document.getElementById('current-tf-label').textContent = TF_MAP[currentTF].label;
    document.getElementById('tf-footer').textContent = currentTF;
    // auto-reload analysis on timeframe change:
    startAnalysis();
  });
});

const statusEl = document.getElementById('status');
const progressEl = document.getElementById('progress');
const tbody = document.getElementById('tbody');
const loadBtn = document.getElementById('load-btn');
const reloadBtn = document.getElementById('reload-btn');
const csvBtn = document.getElementById('csv-btn');
const sortSelect = document.getElementById('sort-select');

loadBtn.addEventListener('click', startAnalysis);
reloadBtn.addEventListener('click', startAnalysis);
csvBtn.addEventListener('click', exportCSV);
sortSelect.addEventListener('change', () => {
  if(window.lastResults) renderTable(window.lastResults);
});

// Utilities: basic numerics
function toFixedNum(n, d=6){ return Number.isFinite(n) ? Number(n.toFixed(d)) : n; }

// Indicator helpers
function sma(values, period){
  if(values.length < period) return null;
  const res = [];
  for(let i=period-1;i<values.length;i++){
    let s=0;
    for(let j=i-period+1;j<=i;j++) s += values[j];
    res.push(s/period);
  }
  return res;
}
function rsiFromCloses(closes, period=14){
  if(closes.length < period+1) return null;
  let gains=0, losses=0;
  for(let i=1;i<=period;i++){
    const diff = closes[i]-closes[i-1];
    if(diff>0) gains+=diff; else losses+=Math.abs(diff);
  }
  let avgGain = gains/period, avgLoss = losses/period;
  for(let i=period+1;i<closes.length;i++){
    const diff = closes[i]-closes[i-1];
    avgGain = ((avgGain*(period-1)) + (diff>0?diff:0))/period;
    avgLoss = ((avgLoss*(period-1)) + (diff<0?Math.abs(diff):0))/period;
  }
  if(avgLoss === 0) return 100;
  const rs = avgGain/avgLoss;
  return 100 - (100/(1+rs));
}

// fetch helpers (with simple retry/backoff)
async function fetchJSON(url, opts={}, tries=3){
  try{
    const r = await fetch(url, opts);
    if(!r.ok) throw new Error('HTTP '+r.status);
    return await r.json();
  } catch(e){
    if(tries>1){
      await new Promise(res=>setTimeout(res, 500));
      return fetchJSON(url, opts, tries-1);
    }
    throw e;
  }
}

// Main flow
async function startAnalysis(){
  statusEl.textContent = 'Зареждане: взимам топ монети от CoinGecko...';
  progressEl.style.width = '4%';
  tbody.innerHTML = '<tr><td colspan="7" class="muted">Събиране на данни... (може да отнеме няколко десетки секунди)</td></tr>';
  try{
    // 1) Top 200 coins by market cap
    const top = await fetchJSON('https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=200&page=1&sparkline=false');
    statusEl.textContent = `Намерени ${top.length} монети. Намиране на Binance символи...`;
    // 2) Get Binance symbols list once
    const exchangeInfo = await fetchJSON('https://api.binance.com/api/v3/exchangeInfo');
    const symbolsSet = new Set(exchangeInfo.symbols.map(s=>s.symbol));
    // Prepare candidates: try mapping coingecko symbol -> SYMBOLUSDT and SYMBOLBUSD
    const candidates = top.map(c=>{
      const sym = (c.symbol || '').toUpperCase();
      return {id:c.id,name:c.name,symbol:sym,coingecko:c};
    });
    // Map to Binance symbols
    const mapped = [];
    for(const c of candidates){
      const try1 = c.symbol + 'USDT';
      const try2 = c.symbol + 'BUSD';
      if(symbolsSet.has(try1)) mapped.push({...c,binanceSymbol:try1});
      else if(symbolsSet.has(try2)) mapped.push({...c,binanceSymbol:try2});
      // else skip (not listed on binance under that ticker)
    }
    if(mapped.length===0){
      tbody.innerHTML = '<tr><td colspan="7" class="muted">Няма съвпадения с Binance символи. Може да се използва друг exchange или различно картографиране.</td></tr>';
      statusEl.textContent = 'Няма налични симвoли на Binance.';
      progressEl.style.width = '0%';
      return;
    }
    statusEl.textContent = `Намерени ${mapped.length} монети с Binance символи. Сваляне на klines за timeframe ${currentTF}...`;
    // 3) For each mapped, fetch klines
    const results = [];
    const total = mapped.length;
    // Limit concurrency to avoid browser hitting API limits
    const BATCH = 6;
    for(let i=0;i<total;i+=BATCH){
      const batch = mapped.slice(i,i+BATCH);
      const promises = batch.map(async item=>{
        try{
          // kline limit: 200, we need maybe last 100 candles to compute indicators (enough)
          const limit = 200;
          const klines = await fetchJSON(`https://api.binance.com/api/v3/klines?symbol=${item.binanceSymbol}&interval=${currentTF === '30m' ? '30m' : currentTF}&limit=${limit}`);
          // klines structure: [ [ openTime, open, high, low, close, ... ], ... ]
          if(!Array.isArray(klines) || klines.length===0) throw new Error('no klines');
          const closes = klines.map(k=>Number(k[4]));
          const lastClose = closes[closes.length-1];
          const prevClose = closes[closes.length-2] || lastClose;
          const pctChange = (lastClose - prevClose)/prevClose*100;
          // SMA(20)
          const sma20 = sma(closes,20);
          let slope = null;
          if(sma20 && sma20.length>=2){
            const sLast = sma20[sma20.length-1];
            const sPrev = sma20[sma20.length-2];
            slope = (sLast - sPrev)/sPrev * 100; // percent slope
          }
          const rsi = rsiFromCloses(closes,14);
          // Simple signal rules:
          let signal = 'hold', comment='';
          if(rsi !== null && slope !== null){
            if(rsi < 35 && slope > 0.25) { signal='buy'; comment='Oversold + rising SMA'; }
            else if(rsi > 70 && slope < -0.25){ signal='sell'; comment='Overbought + falling SMA'; }
            else if(pctChange > 2 && slope > 0.5){ signal='buy'; comment='Strong short-term momentum'; }
            else if(pctChange < -3 && slope < -0.5){ signal='sell'; comment='Strong drop + downtrend'; }
            else comment = 'Няма силен сигнал';
          } else {
            comment = 'Недостатъчно данни';
          }
          return {
            name: item.name,
            symbol: item.symbol,
            binanceSymbol: item.binanceSymbol,
            price: lastClose,
            pctChange: pctChange,
            smaSlope: slope,
            rsi: rsi,
            signal: signal,
            comment: comment
          };
        } catch(e){
          return {name:item.name,symbol:item.symbol,binanceSymbol:item.binanceSymbol, error: String(e)};
        }
      });
      const batchRes = await Promise.all(promises);
      results.push(...batchRes);
      const p = Math.min(100, Math.round((results.length/total)*100));
      progressEl.style.width = p + '%';
      statusEl.textContent = `Обработени ${results.length}/${total}...`;
      // small pause to be polite
      await new Promise(res=>setTimeout(res, 350));
    }

    // store and render
    window.lastResults = results.filter(r=>!r.error);
    statusEl.textContent = `Готово — обработени ${window.lastResults.length} монети (от ${total}).`;
    progressEl.style.width = '100%';
    // apply sort
    renderTable(window.lastResults);
    populateTopLists(window.lastResults);
  } catch(err){
    console.error(err);
    statusEl.textContent = 'Грешка при зареждане: ' + (err.message || err);
    tbody.innerHTML = '<tr><td colspan="7" class="muted">Грешка при сваляне на данни. Гледай конзолата за подробности.</td></tr>';
    progressEl.style.width = '0%';
  }
}

function renderTable(data){
  // sort according to select
  const sort = sortSelect.value;
  let sorted = data.slice();
  if(sort === 'exp') sorted.sort((a,b)=> (b.pctChange||0) - (a.pctChange||0));
  else if(sort === 'price') sorted.sort((a,b)=> (b.price||0) - (a.price||0));
  else if(sort === 'name') sorted.sort((a,b)=> a.name.localeCompare(b.name));
  // render first 200 rows max
  const rows = sorted.slice(0,200).map(r=>{
    const price = r.price!==undefined ? toFixedNum(r.price,6) : '—';
    const pct = r.pctChange!==undefined ? toFixedNum(r.pctChange,2) + '%' : '—';
    const slope = r.smaSlope!==null && r.smaSlope!==undefined ? toFixedNum(r.smaSlope,3) + '%' : '—';
    const rsi = r.rsi!==null && r.rsi!==undefined ? toFixedNum(r.rsi,2) : '—';
    const pillClass = r.signal === 'buy' ? 'buy' : (r.signal==='sell' ? 'sell' : 'hold');
    return `<tr>
      <td><strong>${r.symbol}</strong> <div class="muted">${r.name}<div></td>
      <td>${price}</td>
      <td>${pct}</td>
      <td><span class="pill ${pillClass}">${r.signal.toUpperCase()}</span></td>
      <td>${slope}</td>
      <td>${rsi}</td>
      <td class="muted">${r.comment || ''}</td>
    </tr>`;
  }).join('');
  tbody.innerHTML = rows || '<tr><td colspan="7" class="muted">Няма резултати.</td></tr>';
}

// top lists simple
function populateTopLists(results){
  const up = results.slice().sort((a,b)=> (b.pctChange||0)-(a.pctChange||0)).slice(0,5);
  const down = results.slice().sort((a,b)=> (a.pctChange||0)-(b.pctChange||0)).slice(0,5);
  const upHtml = up.map(r=>`${r.symbol} <span class="muted">${toFixedNum(r.pctChange,2)}%</span>`).join('<br>');
  const downHtml = down.map(r=>`${r.symbol} <span class="muted">${toFixedNum(r.pctChange,2)}%</span>`).join('<br>');
  document.getElementById('top5-up').innerHTML = `<strong>Топ 5 възходящи</strong><br>${upHtml}<hr style="border:none;border-top:1px dashed rgba(255,255,255,0.04)"><strong>Топ 5 низходящи</strong><br>${downHtml}`;
}

// CSV export
function exportCSV(){
  if(!window.lastResults || window.lastResults.length===0){
    alert('Няма данни за експорт — направи анализ първо.');
    return;
  }
  const rows = [
    ['symbol','name','binanceSymbol','price','pctChange','smaSlope','rsi','signal','comment']
  ];
  for(const r of window.lastResults){
    rows.push([
      r.symbol, r.name, r.binanceSymbol || '', r.price || '', r.pctChange || '', r.smaSlope || '', r.rsi || '', r.signal || '', (r.comment||'').replace(/[\n\r,]+/g,' ')
    ]);
  }
  const csv = rows.map(r => r.map(cell=> `"${String(cell).replace(/"/g,'""')}"`).join(',')).join('\n');
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `screener_${currentTF}_${(new Date()).toISOString().slice(0,19)}.csv`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

// auto-start if user wants: (disabled by default)
// startAnalysis();

</script>
</body>
</html>
